#' R6 Class Representing a diagnostic sample
#'
#' @description
#' ClassificationCase provides a coherent structure to keep all information
#' of one diagnostic case used for methylation prediction within a single object.
#' @export

ClassificationCase <- R6::R6Class("ClassificationCase",
                              public = list(
                                #' @field basename Basename (prefix of IDAT file).
                                basename = NA,

                                #' @field beta_values Matrix of beta values.
                                beta_values = NA,

                                #' @field class_type Predicted class of sample.
                                class_type = NA,

                                #' @field class_votes Matrix of class probabilities.
                                class_votes = NA,

                                #' @field cnv Segmented copy number data created by conumee.
                                cnv = NA,

                                #' @field error Boolean, TRUE if error occured during execution
                                #' (default: FALSE).
                                error = FALSE,

                                #' @field error_code Contains error code if execution failed
                                #' (default: NULL).
                                error_code = NULL,

                                #' @field imputed_n Number of imputed data points.
                                imputed_n = NA,

                                #' @field n_probes Number of raw intensity measurements.
                                #' Used to guess array type.
                                n_probes = NA,

                                #' @field normalization_method Method used for normalization.
                                normalization_method = NA,

                                #' @field normalized_data Object of class MethylSet,
                                #' generated by minfi's preprocessing functions.
                                normalized_data = NA,

                                #' @field path Directory containing the input files.
                                path = NA,

                                #' @field platform Auto-detected array platform.
                                platform = NA,

                                #' @field purity List of length 2 with tumor purities estimated
                                #' with RF_Purify package.
                                purity = NA,

                                #' @field raw_data Object of type RGSet containing raw array data
                                #' generated with minfi::read.metharray().
                                raw_data = NA,

                                #' @field rf Object of type "randomForest". Contains the classifier
                                #' object which needs to be supplied while the methods
                                #' run_classification() or run_workflow().
                                rf = NA,

                                #' @field verbose Print informative messages (Boolean, default: TRUE).
                                verbose = NA,

                                #' @description
                                #' Create a new ClassificationCase instance.
                                #' @param basename Basename of sample.
                                #' @param path Input directory with IDAT files.
                                #' @param verbose Print informative messages (Default: TRUE).
                                #' @return A new `ClassificationCase` object.
                                initialize = function(basename, path, verbose = TRUE) {
                                  self$path <- path
                                  self$basename <- basename
                                  self$verbose <- verbose
                                  self$validate(verbose = self$verbose)
                                },

                                #' @description
                                #' Perform input file checks. This is quite extensive actually. After checking whether
                                #' the input files exists, the data are read (to check for corrupt files) and the information
                                #' is futher used to investigate whether the files have the same no. of probes. In addition,
                                #' the array type is guessed based on the number of probes. If any of these steps should go wrong,
                                #' the program records an error code to help narrow down the problem.
                                #' @param verbose Print informative messages (Boolean, default: TRUE).
                                #' Inherits from \code{\link{ClassificationCase$new}}.
                                validate = function(verbose = TRUE) {
                                  # check if supplied basename is valid
                                  if (length(self$basename) != 1) {
                                    self$terminate(error_code = "101")
                                    stop()
                                  }

                                  if (verbose) message("Initializing object, running standard checks:")
                                  if (verbose) message("Basename is valid")

                                  # check if input directory exists
                                  if (!dir.exists(self$path)) {
                                    self$terminate(error_code = "102")
                                    stop()
                                  }

                                  if (verbose) message("Input directory exists")

                                  # check if red and green idat files exist
                                  file_grn <- file.path(self$path, paste0(self$basename, "_Grn.idat"))
                                  file_red <- file.path(self$path, paste0(self$basename, "_Red.idat"))

                                  if (!file.exists(file_grn)) {
                                    self$terminate(error_code = "103")
                                    stop()
                                  }

                                  if (!file.exists(file_red)) {
                                    self$terminate(error_code = "104")
                                    stop()
                                  }

                                  if (verbose) message("Input files exists")

                                  if (verbose) message("Testing if files can be read...")

                                  # test if arrays can be read and have the same amount of probes
                                  grn <- tryCatch(expr = {illuminaio::readIDAT(file = file_grn)},
                                                  error = function() "error")
                                  red <- tryCatch(expr = {illuminaio::readIDAT(file = file_red)},
                                                  error = function() "error")

                                  if (!is.list(grn)){
                                    self$terminate(error_code = "105")
                                    stop()
                                  }

                                  if (!is.list(red)){
                                    self$terminate(error_code = "106")
                                    stop()
                                  }

                                  if (verbose) message("Files read successfully!")

                                  # extract number of physical probes
                                  nprobes_grn <- nrow(grn[["Quants"]])
                                  nprobes_red <- nrow(red[["Quants"]])

                                  # quit if number of probes do not match
                                  if (nprobes_grn != nprobes_red) {
                                    self$terminate(error_code = "107")
                                    stop()
                                  }

                                  self$n_probes <- nprobes_grn

                                  if (verbose) message("Matching number of probes for RED and GRN files")

                                  # detect platform based on number of probes
                                  self$platform <- guess_array_type(self$n_probes)

                                  # quit if array type is unsupported
                                  supp <- c("IlluminaHumanMethylation450k", "IlluminaHumanMethylationEPIC")

                                  if (!self$platform %in% supp) {
                                    self$terminate(error_code = "108")
                                    stop()
                                  }

                                  if (verbose) message(paste0("Detected platform: ", self$platform))
                                  if (verbose) message("Input checks completed succesfully")
                                },
                                #' @description
                                #' Internal function to terminate processing and record error code.
                                #' @param error_code Error code encountered.
                                terminate = function(error_code) {
                                  if (length(error_code) != 1){
                                    stop("Invalid error code")
                                  } else {
                                    error_code <- as.character(error_code)
                                  }
                                  self$error <- TRUE
                                  self$error_code <- error_code
                                  message(paste0("Encountered fatal error, execution stopped (Error code: ", error_code, ")"))
                                },
                                #' @description
                                #' Load data for sample
                                #' @param verbose Print helpful messages (default: TRUE)
                                load_data = function(verbose = TRUE) {
                                  path <- file.path(self$path, self$basename)
                                  self$raw_data <- minfi::read.metharray(path)
                                  if (verbose) message(paste0("Successfully loaded data for: ", self$basename))
                                  invisible(self)
                                },
                                #' @description
                                #' Perform background normalization
                                #' @param preprocess_function Function used for preprocessing of the data.
                                #' If NULL, will use minfi::preprocessIllumina() to perform background
                                #' intensity correction (Default: NULL)
                                #' @param verbose Print helpful messages (default: TRUE)
                                normalize_data = function(preprocess_function = NULL, verbose = TRUE) {
                                  if (is.null(preprocess_function)) {
                                    preprocess_function <- minfi::preprocessIllumina
                                  }
                                  self$normalized_data <- preprocess_function(self$raw_data)
                                  self$normalization_method <- unname(self$normalized_data@preprocessMethod[1])
                                  if (verbose) message(paste0("Data normalized with Method: ", self$normalization_method))
                                  invisible(self)
                                },
                                #' @description
                                #' Extract beta values from MethylSet object
                                #' @param verbose Print helpful messages (default: TRUE)
                                get_betas = function(verbose = TRUE) {
                                  self$beta_values <- minfi::getBeta(self$normalized_data)
                                  if (verbose) message("Extracted beta values")
                                  invisible(self)
                                },
                                #' @description
                                #' Perform missing data imputation
                                #' @param imputation_function Function used to perform imputation.
                                #' Has to be able to use matrix of beta values for a single sample
                                #' as input. If NULL, performs random data imputation (beta values
                                #' are to fill in gaps are sampled from available data, Default: NULL)
                                #' @param verbose Print helpful messages (Default: TRUE)
                                impute_data = function(imputation_function = NULL, verbose = TRUE) {
                                  # imputation returns (1) matrix and (2) proportion of NAs
                                  if (is.null(imputation_function)) {
                                    imputation_function <- impute_random
                                  }
                                  imp <- imputation_function(self$beta_values)
                                  # update beta values in place
                                  self$beta_values <- imp$imputed
                                  self$imputed_n <- imp$n
                                  if (verbose) message(paste0("Imputed data for n = ", imp$n, " probes"))
                                  invisible(self)
                                },
                                #' @description
                                #' Classify tumor sample
                                #' @param verbose Print helpful messages (default: TRUE)
                                #' @param rf_object RandomForest predictor object
                                run_classification = function(rf_object, verbose = TRUE) {
                                  # copy classifier into object
                                  self$rf <- rf_object
                                  # extract variables
                                  vars <- get_rf_variables(self$rf)
                                  # select beta values
                                  input_data <- self$beta_values[vars, ,drop = FALSE]
                                  self$class_type <- predict(object = self$rf, newdata = t(input_data), type = "response")
                                  self$class_votes <- predict(object = self$rf, newdata = t(input_data), type = "vote")
                                  if (verbose) message("Classification completed")
                                  invisible(self)
                                },
                                #' @description
                                #' Prepare copy-number plot
                                #' @param verbose Print helpful messages (default: TRUE)
                                prepare_cnv = function(verbose = TRUE) {

                                  # pick prepared annotation and normal controls for platform
                                  anno <- switch(self$platform,
                                                 IlluminaHumanMethylationEPIC = get("ConumeeAnnoEpic"),
                                                 IlluminaHumanMethylation450k = get("ConumeeAnno450k"))
                                  ctrls <- switch(self$platform,
                                                  IlluminaHumanMethylationEPIC = get("NormalControlsEpic"),
                                                  IlluminaHumanMethylation450k = get("NormalControls450k"))

                                  # run conumee workflow
                                  sample <- conumee::CNV.load(self$normalized_data)
                                  ctrls <- conumee::CNV.load(ctrls)
                                  cnv_fit <- conumee::CNV.fit(query = sample, ref = ctrls, anno = anno)
                                  cnv_binned <- conumee::CNV.bin(cnv_fit)
                                  self$cnv <- conumee::CNV.segment(cnv_binned)
                                  if (verbose) message("Successfully computed CNV profile")
                                  invisible(self)
                                },
                                #' @description
                                #' Perform tumor purity estimation
                                #' @param verbose Print helpful messages (default: TRUE)
                                estimate_purity = function(verbose = TRUE) {
                                  betas <- self$beta_values

                                  # load RF purity estimation objects
                                  rf_absolute <- get("RFpurify_ABSOLUTE")
                                  rf_estimate <- get("RFpurify_ESTIMATE")

                                  # extract variables used for classifier
                                  vars_absolute <- get_rf_variables(rf_absolute)
                                  vars_estimate <- get_rf_variables(rf_estimate)

                                  # prepare data for purity estimation
                                  betas_absolute <- betas[match(vars_absolute, rownames(betas)), , drop = FALSE]
                                  betas_estimate <- betas[match(vars_estimate, rownames(betas)), , drop = FALSE]

                                  # perform estimation
                                  purity_absolute <- predict(rf_absolute, t(betas_absolute))
                                  purity_estimate <- predict(rf_estimate, t(betas_estimate))

                                  # convert to percentages
                                  purity_absolute <- round(purity_absolute * 100, digits = 2)
                                  purity_estimate <- round(purity_estimate * 100, digits = 2)

                                  # save data
                                  self$purity = list(absolute = unname(purity_absolute),
                                                     estimate = unname(purity_estimate))

                                  if (verbose) message("Tumor purity estimation completed")
                                  invisible(self)
                                },
                                #' @description
                                #' Run full sample workflow
                                #' @param verbose Print helpful messages (default: TRUE)
                                #' @param rf_object RandomForest predictor object. Passed to
                                #' run_classification()
                                run_workflow = function(rf_object, verbose = TRUE) {
                                  self$load_data(verbose = verbose)
                                  self$normalize_data(verbose = verbose)
                                  self$get_betas(verbose = verbose)
                                  self$impute_data(verbose = verbose)
                                  self$run_classification(rf_object = rf_object, verbose = verbose)
                                  self$prepare_cnv(verbose = verbose)
                                  self$estimate_purity(verbose = verbose)
                                })
)
